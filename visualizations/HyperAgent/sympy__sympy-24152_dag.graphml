<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="d8" for="edge" attr.name="edge_type" attr.type="string" />
  <key id="d7" for="node" attr.name="context" attr.type="string" />
  <key id="d6" for="node" attr.name="index" attr.type="long" />
  <key id="d5" for="node" attr.name="content" attr.type="string" />
  <key id="d4" for="node" attr.name="type" attr.type="string" />
  <key id="d3" for="node" attr.name="id" attr.type="string" />
  <key id="d2" for="node" attr.name="label" attr.type="string" />
  <key id="d1" for="graph" attr.name="problem_statement" attr.type="string" />
  <key id="d0" for="graph" attr.name="instance_id" attr.type="string" />
  <graph edgedefault="directed">
    <node id="node_0">
      <data key="d2">Init</data>
      <data key="d3">node_0</data>
      <data key="d4">initialization</data>
      <data key="d5">HyperAgent_sympy__sympy-24152 - INFO - Initialized HyperAgent instance sympy__sympy-24152</data>
      <data key="d6">0</data>
      <data key="d7" />
    </node>
    <node id="node_1">
      <data key="d2">Init</data>
      <data key="d3">node_1</data>
      <data key="d4">initialization</data>
      <data key="d5">HyperAgent_sympy__sympy-24152 - INFO - Initialized HyperAgent instance sympy__sympy-24152</data>
      <data key="d6">1</data>
      <data key="d7" />
    </node>
    <node id="node_2">
      <data key="d2">Init</data>
      <data key="d3">node_2</data>
      <data key="d4">initialization</data>
      <data key="d5">HyperAgent_sympy__sympy-24152 - INFO - Initialized HyperAgent instance sympy__sympy-24152</data>
      <data key="d6">2</data>
      <data key="d7" />
    </node>
    <edge source="node_0" target="node_1">
      <data key="d8">sequential</data>
    </edge>
    <edge source="node_1" target="node_2">
      <data key="d8">sequential</data>
    </edge>
    <data key="d0">sympy__sympy-24152</data>
    <data key="d1">["Bug in expand of TensorProduct + Workaround + Fix", "### Error description\r", "The expansion of a TensorProduct object stops incomplete if summands in the tensor product factors have (scalar) factors, e.g.\r", "```\r", "from sympy import *\r", "from sympy.physics.quantum import *\r", "U = Operator('U')\r", "V = Operator('V')\r", "P = TensorProduct(2*U - V, U + V)\r", "print(P) \r", "# (2*U - V)x(U + V)\r", "print(P.expand(tensorproduct=True)) \r", "#result: 2*Ux(U + V) - Vx(U + V) #expansion has missed 2nd tensor factor and is incomplete\r", "```\r", "This is clearly not the expected behaviour. It also effects other functions that rely on .expand(tensorproduct=True), as e.g. qapply() .\r", "\r", "### Work around\r", "Repeat .expand(tensorproduct=True) as may times as there are tensor factors, resp. until the expanded term does no longer change. This is however only reasonable in interactive session and not in algorithms.\r", "\r", "### Code Fix\r", ".expand relies on the method TensorProduct._eval_expand_tensorproduct(). The issue arises from an inprecise check in TensorProduct._eval_expand_tensorproduct() whether a recursive call is required; it fails when the creation of a TensorProduct object returns commutative (scalar) factors up front: in that case the constructor returns a Mul(c_factors, TensorProduct(..)).\r", "I thus propose the following  code fix in TensorProduct._eval_expand_tensorproduct() in quantum/tensorproduct.py.  I have marked the four lines to be added / modified:\r", "```\r", "    def _eval_expand_tensorproduct(self, **hints):\r", "                ...\r", "                for aa in args[i].args:\r", "                    tp = TensorProduct(*args[:i] + (aa,) + args[i + 1:])\r", "                    c_part, nc_part = tp.args_cnc() #added\r", "                    if len(nc_part)==1 and isinstance(nc_part[0], TensorProduct): #modified\r", "                        nc_part = (nc_part[0]._eval_expand_tensorproduct(), ) #modified\r", "                    add_args.append(Mul(*c_part)*Mul(*nc_part)) #modified\r", "                break\r", "                ...\r", "```\r", "The fix splits of commutative (scalar) factors from the tp returned. The TensorProduct object will be the one nc factor in nc_part (see TensorProduct.__new__ constructor), if any. Note that the constructor will return 0 if a tensor factor is 0, so there is no guarantee that tp contains a TensorProduct object (e.g. TensorProduct(U-U, U+V).\r", "\r", "\r", "", ""]</data>
  </graph>
</graphml>
